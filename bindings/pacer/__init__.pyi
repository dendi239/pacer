from typing import overload, Callable, Tuple, List, Any

# // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# // <litgen_stub>  // Autogenerated code below! Do not edit!
####################    <generated_from:datatypes.hpp>    ####################

class GPSSample:
    lat: float
    lon: float
    altitude: float
    full_speed: float
    ground_speed: float
    def __init__(
        self,
        lat: float = float(),
        lon: float = float(),
        altitude: float = float(),
        full_speed: float = float(),
        ground_speed: float = float(),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

#  ------------------------------------------------------------------------
#      <template specializations for class PointInTime>
class PointInTime_GPSSample:  # Python specialization for PointInTime<GPSSample>
    point: GPSSample
    time: float

    def __init__(self, point: GPSSample = GPSSample(), time: float = float()) -> None:
        """Auto-generated default constructor with named params"""
        pass

#      </template specializations for class PointInTime>
#  ------------------------------------------------------------------------

class Vec3f:
    x: float = 0
    y: float = 0
    z: float = 0

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, x: float, y: float, z: float) -> None:
        pass

    @overload
    def __getitem__(self, index: int) -> float:
        pass

    @overload
    def __getitem__(self, index: int) -> float:
        pass

####################    </generated_from:datatypes.hpp>    ####################

####################    <generated_from:geometry.hpp>    ####################

def to_im_plot_point(index: int, data: Any) -> ImPlotPoint:
    pass

class Point:
    x: float = 0
    y: float = 0

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, x: float, y: float) -> None:
        pass

    @overload
    def __getitem__(self, index: int) -> float:
        pass

    @overload
    def __getitem__(self, index: int) -> float:
        pass

    def rot(self) -> Point:
        pass

@overload
def to_point(x: Point) -> Point:
    pass

@overload
def to_point(s: GPSSample) -> Point:
    pass

@overload
def to_point(v: Vec3f) -> Point:
    pass

# template <typename Concrete, typename T, size_t N>
# Point ToPoint(const LinearOperators<Concrete, T, N> &x) {
#   return Point{static_cast<const Concrete &>(x)[0],
#                static_cast<const Concrete &>(x)[1]};
# }

class Segment:
    first: Point
    second: Point

    def intersects(self, fst: Point, snd: Point, ratio: float) -> bool:
        """Returns True if segments intersects, if ratio is non-null, it will satisfy:
        fst * (1 - ratio) + snd  lies  on present segment.
        """
        pass

    def __eq__(self, other: Segment) -> bool:
        pass

    def __init__(self, first: Point = Point(), second: Point = Point()) -> None:
        """Auto-generated default constructor with named params"""
        pass

class CoordinateSystem:
    # Coordinate system maps GPS coordinates to local coordinates.
    #  N.B. All local coordinates measured in meters.
    #
    # I employ following formulas:
    #   x = h_c * R_equator * cos(lat) * cos(lon)
    #   y = h_c * R_equator * cos(lat) * sin(lon)
    #   z = h_c * R_pole * sin(lat)
    #
    # Where h_c is the height compenstaion factor:
    #   h_c = 1 + altitude / R_equator
    #
    # Basis for resulting coordinate system is almost normalised gradients along
    # lon/lat/altiude coordinates: only altitude slightly differs to have
    # ortogonal system:
    #  dx = (-R_equator cos(lat) sin(lon), R_equator cos(lat) cos(lon), 0)
    #  dy = (-R_equator sin(lat) cos(lon), -R_equator sin(lat) sin(lon),
    #        R_pole cos(lat))
    #  dz = (R_pole cos(lat) cos(lon), R_pole cos(lat) sin(lon),
    #        R_equator sin(lat))
    #
    # This is most likely not the best way to do this, but it works for now.

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, origin: GPSSample) -> None:
        pass

    def local(self, point: GPSSample) -> Vec3f:
        """/ Converts point to local coordinate system."""
        pass

    def global_(self, point: Vec3f) -> GPSSample:
        """/ Maps local-coordinate point back to gps sample.
        / N.B. Speed is not preserved.
        """
        pass

    def distance(self, from_: GPSSample, to: GPSSample) -> float:
        pass

@overload
def interpolate(from_: Point, to: Point, ratio: float) -> Point:
    pass

@overload
def interpolate(from_: GPSSample, to: GPSSample, ratio: float) -> GPSSample:
    pass

# template <typename Concrete, typename T, size_t N>
# Concrete Interpolate(const LinearOperators<Concrete, T, N> &from,
#                      const LinearOperators<Concrete, T, N> &to, double ratio)
#                      {
#   return static_cast<Concrete>(static_cast<const Concrete &>(from) *
#                                    (1 - ratio) +
#                                static_cast<const Concrete &>(to) * ratio);
# }

####################    </generated_from:geometry.hpp>    ####################

####################    <generated_from:laps.hpp>    ####################

class Lap:
    width: float

    points: List[PointInTime[GPSSample]]
    cum_distances: List[float]

    def fill_distances(self, cs: CoordinateSystem) -> None:
        pass

    def lap_time(self) -> float:
        pass

    def count(self) -> int:
        pass

    def resample(self, lap: Lap, cs: CoordinateSystem) -> Lap:
        pass

    def timing_lines_count(self) -> int:
        pass

    def timing_line(self, index: int, cs: CoordinateSystem) -> Segment:
        pass

    def __init__(
        self,
        width: float = float(),
        points: List[PointInTime[GPSSample]] = List[PointInTime < GPSSample] > (),
        cum_distances: List[float] = List[float](),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class Sectors:
    start_line: Segment
    sector_lines: List[Segment]
    def __init__(
        self,
        start_line: Segment = Segment(),
        sector_lines: List[Segment] = List[Segment](),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class Laps:
    def update(self) -> None:
        """/ Updates all laps given updated start_line and sector_lines"""
        pass

    def pick_random_start(self) -> Segment:
        """/ Picks a starting point for start_line.
        / Default implementation builds segment perpendicular to median segment.
        """
        pass
    # ---------------------------- PRESENTATION -------------------------------//

    def set_coordinate_system(self, coordinate_system: CoordinateSystem) -> None:
        pass

    def min_max(self) -> Tuple[Point, Point]:
        """/ Gets bounding box for entire thing, might be cached
        / as depends on points only.
        """
        pass
    # -------------------------------- LAPS -----------------------------------//

    sectors: Sectors

    def laps_count(self) -> int:
        pass

    def lap_entry_speed(self, lap: int) -> float:
        pass

    def lap_time(self, lap: int) -> float:
        pass

    def sample_count(self, lap: int) -> int:
        pass

    def start_timestamp(self, lap: int) -> float:
        pass

    def at(self, lap: int, row: int) -> PointInTime_GPSSample:
        pass

    def speed(self, lap: int, row: int) -> float:
        pass

    def distance(self, lap: int, row: int) -> float:
        pass

    def get_lap_distance(self, index: int, cs: CoordinateSystem) -> float:
        pass

    def get_lap(self, lap: int) -> Lap:
        pass
    # ------------------------------- SECTORS ---------------------------------//

    def sector_count(self) -> int:
        pass

    def recorded_sectors(self) -> int:
        pass

    def clear_sectors(self) -> None:
        pass

    def sector_time(self, sector: int) -> float:
        pass

    def sector_start_timestamp(self, sector: int) -> float:
        pass

    def sector_entry_speed(self, sector: int) -> float:
        pass
    # ------------------------------ RAW POINTS -------------------------------//

    def add_point(self, s: GPSSample, t: float) -> None:
        pass

    def point_count(self) -> int:
        pass

    def get_point(self, row: int) -> PointInTime_GPSSample:
        pass

    def clear_points(self) -> None:
        pass

    def __init__(self, sectors: Sectors = Sectors()) -> None:
        """Auto-generated default constructor with named params"""
        pass

####################    </generated_from:laps.hpp>    ####################

####################    <generated_from:gps-source.hpp>    ####################

class RawGPSSource:
    """Base class for raw GPS source.

    Being raw in this context means that it does not provide any meaningful
    timestamps to work with.
    """

    def __init__(self) -> None:
        pass

    def read_samples(self, on_sample: Callable[[GPSSample, int, int], None]) -> int:
        pass

    def seek(self, target: float) -> int:  # overridable (pure virtual)
        """Seeks to data chunk covering target."""
        pass

    def next(self) -> None:  # overridable (pure virtual)
        """Proceeds to next piece of data."""
        pass

    def is_end(self) -> bool:  # overridable (pure virtual)
        """Checks whenever we already reachend end of the stream."""
        pass

    def current_time_span(self) -> Tuple[float, float]:  # overridable (pure virtual)
        """Returns current samples' time span."""
        pass

    def get_total_duration(self) -> float:  # overridable (pure virtual)
        """Gets total MP4 duration."""
        pass

class GPMFSource(RawGPSSource):
    """Handler for GPMF track inside MP4 container.

    Allows for traversing media file and getting GPS data out of it.

    TODO: Provide even more low-level access to underlying samples,
          might be useful to keep buffer for data in some sort of iterator
          with option to iterate over GPSSample-s on top of it.
    """

    @overload
    def __init__(self, mp4handle: int) -> None:
        pass

    @overload
    def __init__(self, filename: str) -> None:
        pass

    def seek(self, target: float) -> int:
        """Seeks to data chunk covering target."""
        pass

    def next(self) -> None:
        """Proceeds to next piece of data."""
        pass

    def is_end(self) -> bool:
        """Checks whenever we already reachend end of the stream."""
        pass

    def current_time_span(self) -> Tuple[float, float]:
        """Returns current samples' time span."""
        pass

    def get_total_duration(self) -> float:
        """Gets total MP4 duration."""
        pass

class SequentialGPSSource(RawGPSSource):
    def __init__(self, left: RawGPSSource, right: RawGPSSource) -> None:
        pass

    def get_total_duration(self) -> float:
        pass

    def is_end(self) -> bool:
        pass

    def seek(self, target: float) -> int:
        pass

    def next(self) -> None:
        pass

    def current_time_span(self) -> Tuple[float, float]:
        """Returns current samples' time span."""
        pass

class DatVersion(enum.Enum):
    just_data = enum.auto()  # (= 0)
    with_timestamp = enum.auto()  # (= 1)

####################    </generated_from:gps-source.hpp>    ####################

####################    <generated_from:laps-display.hpp>    ####################

class LapsDisplay:
    laps: Laps
    selected_lap: int = -1

    cs: CoordinateSystem

    def to_im_plot_point(self, s: GPSSample) -> ImPlotPoint:
        pass
    bounds: Tuple[Point, Point] = Tuple[Point, Point]({1, 1}, {0, 0})

    def drag_timing_line(self, s: Segment, name: str, drag_id: int) -> None:
        pass

    def display_map(self) -> None:
        pass

    def display_lap_telemetry(self) -> None:
        pass

    def display_table(self) -> bool:
        pass

    def __init__(
        self, selected_lap: int = -1, cs: CoordinateSystem = CoordinateSystem()
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class DeltaLapsComparision:
    reference_lap: Lap
    cs: CoordinateSystem

    def plot_sticks(self) -> None:
        pass

    def draw_slider(self) -> None:
        pass
    selected_laps: std.unordered_set[int] = (
        std.unordered_set < int > ()
    )  # {19, 24, 28, 35, 36};

    def display(self, laps: Laps) -> None:
        pass

    def __init__(
        self,
        reference_lap: Lap = Lap(),
        cs: CoordinateSystem = CoordinateSystem(),
        selected_laps: std.unordered_set[int] = std.unordered_set < int > (),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

####################    </generated_from:laps-display.hpp>    ####################

# // </litgen_stub> // Autogenerated code end
# // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
