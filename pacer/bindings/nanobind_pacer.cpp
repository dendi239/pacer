#include <nanobind/nanobind.h>
#include <nanobind/ndarray.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/pair.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/unordered_set.h>
#include <nanobind/stl/vector.h>
#include <nanobind/trampoline.h>

#include <pacer/datatypes/datatypes.hpp>
#include <pacer/geometry/geometry.hpp>
#include <pacer/gps-source/gps-source.hpp>
#include <pacer/laps-display/laps-display.hpp>
#include <pacer/laps/laps.hpp>

namespace nb = nanobind;
using namespace pacer;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <litgen_glue_code>  // Autogenerated code

namespace pacer {
// helper type to enable overriding virtual methods in python
class RawGPSSource_trampoline : public RawGPSSource
{
public:
    NB_TRAMPOLINE(RawGPSSource, 5);

    uint32_t Seek(double target) override
    {
        NB_OVERRIDE_PURE_NAME(
            "seek", // function name (python)
            Seek, // function name (c++)
            target // params
        );
    }
    void Next() override
    {
        NB_OVERRIDE_PURE_NAME(
            "next", // function name (python)
            Next // function name (c++)
        );
    }
    bool IsEnd() override
    {
        NB_OVERRIDE_PURE_NAME(
            "is_end", // function name (python)
            IsEnd // function name (c++)
        );
    }
    std::pair<double, double> CurrentTimeSpan() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "current_time_span", // function name (python)
            CurrentTimeSpan // function name (c++)
        );
    }
    double GetTotalDuration() const override
    {
        NB_OVERRIDE_PURE_NAME(
            "get_total_duration", // function name (python)
            GetTotalDuration // function name (c++)
        );
    }
};
}  // namespace pacer

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

void py_init_module_pacer(nb::module_ &m) {
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! <litgen_pydef> // Autogenerated code
  ////////////////////    <generated_from:datatypes.hpp>    ////////////////////
  auto pyClassGPSSample =
      nb::class_<pacer::GPSSample>
          (m, "GPSSample", "")
      .def("__init__", [](pacer::GPSSample * self, double lat = double(), double lon = double(), double altitude = double(), double full_speed = double(), double ground_speed = double())
      {
          new (self) pacer::GPSSample();  // placement new
          auto r_ctor_ = self;
          r_ctor_->lat = lat;
          r_ctor_->lon = lon;
          r_ctor_->altitude = altitude;
          r_ctor_->full_speed = full_speed;
          r_ctor_->ground_speed = ground_speed;
      },
      nb::arg("lat") = double(), nb::arg("lon") = double(), nb::arg("altitude") = double(), nb::arg("full_speed") = double(), nb::arg("ground_speed") = double()
      )
      .def_rw("lat", &pacer::GPSSample::lat, "")
      .def_rw("lon", &pacer::GPSSample::lon, "")
      .def_rw("altitude", &pacer::GPSSample::altitude, "")
      .def_rw("full_speed", &pacer::GPSSample::full_speed, "")
      .def_rw("ground_speed", &pacer::GPSSample::ground_speed, "")
      ;


  auto pyClassPointInTime_GPSSample =
      nb::class_<pacer::PointInTime<GPSSample>>
          (m, "PointInTime_GPSSample", "")
      .def("__init__", [](pacer::PointInTime<GPSSample> * self, pacer::GPSSample point = pacer::GPSSample(), double time = double())
      {
          new (self) pacer::PointInTime<GPSSample>();  // placement new
          auto r_ctor_ = self;
          r_ctor_->point = point;
          r_ctor_->time = time;
      },
      nb::arg("point") = pacer::GPSSample(), nb::arg("time") = double()
      )
      .def_rw("point", &pacer::PointInTime<GPSSample>::point, "")
      .def_rw("time", &pacer::PointInTime<GPSSample>::time, "")
      ;


  auto pyClassVec3f =
      nb::class_<pacer::Vec3f>
          (m, "Vec3f", "")
      .def_rw("x", &pacer::Vec3f::x, "")
      .def_rw("y", &pacer::Vec3f::y, "")
      .def_rw("z", &pacer::Vec3f::z, "")
      .def(nb::init<>())
      .def(nb::init<double, double, double>(),
          nb::arg("x"), nb::arg("y"), nb::arg("z"))
      .def("__getitem__",
          nb::overload_cast<size_t>(&pacer::Vec3f::operator[]), nb::arg("index"))
      .def("__getitem__",
          nb::overload_cast<size_t>(&pacer::Vec3f::operator[], nb::const_), nb::arg("index"))
      ;
  ////////////////////    </generated_from:datatypes.hpp>    ////////////////////


  ////////////////////    <generated_from:geometry.hpp>    ////////////////////
  m.def("to_im_plot_point",
      pacer::ToImPlotPoint, nb::arg("index"), nb::arg("data"));


  auto pyClassPoint =
      nb::class_<pacer::Point>
          (m, "Point", "")
      .def_rw("x", &pacer::Point::x, "")
      .def_rw("y", &pacer::Point::y, "")
      .def(nb::init<>())
      .def(nb::init<double, double>(),
          nb::arg("x"), nb::arg("y"))
      .def("__getitem__",
          nb::overload_cast<size_t>(&pacer::Point::operator[], nb::const_), nb::arg("index"))
      .def("__getitem__",
          nb::overload_cast<size_t>(&pacer::Point::operator[]), nb::arg("index"))
      .def("rot",
          &pacer::Point::Rot)
      ;


  m.def("to_point",
      nb::overload_cast<pacer::Point>(pacer::ToPoint), nb::arg("x"));

  m.def("to_point",
      nb::overload_cast<GPSSample>(pacer::ToPoint), nb::arg("s"));

  m.def("to_point",
      nb::overload_cast<Vec3f>(pacer::ToPoint), nb::arg("v"));


  auto pyClassSegment =
      nb::class_<pacer::Segment>
          (m, "Segment", "")
      .def("__init__", [](pacer::Segment * self, pacer::Point first = pacer::Point(), pacer::Point second = pacer::Point())
      {
          new (self) pacer::Segment();  // placement new
          auto r_ctor_ = self;
          r_ctor_->first = first;
          r_ctor_->second = second;
      },
      nb::arg("first") = pacer::Point(), nb::arg("second") = pacer::Point()
      )
      .def_rw("first", &pacer::Segment::first, "")
      .def_rw("second", &pacer::Segment::second, "")
      .def("intersects",
          &pacer::Segment::Intersects,
          nb::arg("fst"), nb::arg("snd"), nb::arg("ratio"),
          " Returns True if segments intersects, if ratio is non-null, it will satisfy:\n   fst * (1 - ratio) + snd  lies  on present segment.")
      .def("__eq__",
          &pacer::Segment::operator==, nb::arg("other"))
      ;


  auto pyClassCoordinateSystem =
      nb::class_<pacer::CoordinateSystem>
          (m, "CoordinateSystem", "")
      .def(nb::init<>())
      .def(nb::init<GPSSample>(),
          nb::arg("origin"))
      .def("local",
          &pacer::CoordinateSystem::Local,
          nb::arg("point"),
          "/ Converts point to local coordinate system.")
      .def("global_",
          &pacer::CoordinateSystem::Global,
          nb::arg("point"),
          "/ Maps local-coordinate point back to gps sample.\n/ N.B. Speed is not preserved.")
      .def("distance",
          &pacer::CoordinateSystem::Distance, nb::arg("from_"), nb::arg("to"))
      ;


  m.def("interpolate",
      nb::overload_cast<pacer::Point, pacer::Point, double>(pacer::Interpolate), nb::arg("from_"), nb::arg("to"), nb::arg("ratio"));

  m.def("interpolate",
      nb::overload_cast<GPSSample, GPSSample, double>(pacer::Interpolate), nb::arg("from_"), nb::arg("to"), nb::arg("ratio"));
  ////////////////////    </generated_from:geometry.hpp>    ////////////////////


  ////////////////////    <generated_from:laps.hpp>    ////////////////////
  auto pyClassLap =
      nb::class_<pacer::Lap>
          (m, "Lap", "")
      .def("__init__", [](pacer::Lap * self, float width = float(), std::vector<PointInTime<GPSSample>> points = std::vector<PointInTime<GPSSample>>(), std::vector<double> cum_distances = std::vector<double>())
      {
          new (self) pacer::Lap();  // placement new
          auto r_ctor_ = self;
          r_ctor_->width = width;
          r_ctor_->points = points;
          r_ctor_->cum_distances = cum_distances;
      },
      nb::arg("width") = float(), nb::arg("points") = std::vector<PointInTime<GPSSample>>(), nb::arg("cum_distances") = std::vector<double>()
      )
      .def_rw("width", &pacer::Lap::width, "")
      .def_rw("points", &pacer::Lap::points, "")
      .def_rw("cum_distances", &pacer::Lap::cum_distances, "")
      .def("fill_distances",
          &pacer::Lap::FillDistances, nb::arg("cs"))
      .def("lap_time",
          &pacer::Lap::LapTime)
      .def("count",
          &pacer::Lap::Count)
      .def("resample",
          &pacer::Lap::Resample, nb::arg("lap"), nb::arg("cs"))
      .def("timing_lines_count",
          &pacer::Lap::TimingLinesCount)
      .def("timing_line",
          &pacer::Lap::TimingLine, nb::arg("index"), nb::arg("cs"))
      ;


  auto pyClassSectors =
      nb::class_<pacer::Sectors>
          (m, "Sectors", "")
      .def("__init__", [](pacer::Sectors * self, Segment start_line = Segment(), std::vector<Segment> sector_lines = std::vector<Segment>())
      {
          new (self) pacer::Sectors();  // placement new
          auto r_ctor_ = self;
          r_ctor_->start_line = start_line;
          r_ctor_->sector_lines = sector_lines;
      },
      nb::arg("start_line") = Segment(), nb::arg("sector_lines") = std::vector<Segment>()
      )
      .def_rw("start_line", &pacer::Sectors::start_line, "")
      .def_rw("sector_lines", &pacer::Sectors::sector_lines, "")
      ;


  auto pyClassLaps =
      nb::class_<pacer::Laps>
          (m, "Laps", "")
      .def("__init__", [](pacer::Laps * self, pacer::Sectors sectors = pacer::Sectors())
      {
          new (self) pacer::Laps();  // placement new
          auto r_ctor_ = self;
          r_ctor_->sectors = sectors;
      },
      nb::arg("sectors") = pacer::Sectors()
      )
      .def("update",
          &pacer::Laps::Update, "/ Updates all laps given updated start_line and sector_lines")
      .def("pick_random_start",
          &pacer::Laps::PickRandomStart, "/ Picks a starting point for start_line.\n/ Default implementation builds segment perpendicular to median segment.")
      .def("set_coordinate_system",
          &pacer::Laps::SetCoordinateSystem, nb::arg("coordinate_system"))
      .def("min_max",
          &pacer::Laps::MinMax, "/ Gets bounding box for entire thing, might be cached\n/ as depends on points only.")
      .def_rw("sectors", &pacer::Laps::sectors, "")
      .def("laps_count",
          &pacer::Laps::LapsCount)
      .def("lap_entry_speed",
          &pacer::Laps::LapEntrySpeed, nb::arg("lap"))
      .def("lap_time",
          &pacer::Laps::LapTime, nb::arg("lap"))
      .def("sample_count",
          &pacer::Laps::SampleCount, nb::arg("lap"))
      .def("start_timestamp",
          &pacer::Laps::StartTimestamp, nb::arg("lap"))
      .def("at",
          &pacer::Laps::At, nb::arg("lap"), nb::arg("row"))
      .def("speed",
          &pacer::Laps::Speed, nb::arg("lap"), nb::arg("row"))
      .def("distance",
          &pacer::Laps::Distance, nb::arg("lap"), nb::arg("row"))
      .def("get_lap_distance",
          &pacer::Laps::GetLapDistance, nb::arg("index"), nb::arg("cs"))
      .def("get_lap",
          &pacer::Laps::GetLap, nb::arg("lap"))
      .def("sector_count",
          &pacer::Laps::SectorCount)
      .def("recorded_sectors",
          &pacer::Laps::RecordedSectors)
      .def("clear_sectors",
          &pacer::Laps::ClearSectors)
      .def("sector_time",
          &pacer::Laps::SectorTime, nb::arg("sector"))
      .def("sector_start_timestamp",
          &pacer::Laps::SectorStartTimestamp, nb::arg("sector"))
      .def("sector_entry_speed",
          &pacer::Laps::SectorEntrySpeed, nb::arg("sector"))
      .def("add_point",
          &pacer::Laps::AddPoint, nb::arg("s"), nb::arg("t"))
      .def("point_count",
          &pacer::Laps::PointCount)
      .def("get_point",
          &pacer::Laps::GetPoint, nb::arg("row"))
      .def("clear_points",
          &pacer::Laps::ClearPoints)
      ;
  ////////////////////    </generated_from:laps.hpp>    ////////////////////


  ////////////////////    <generated_from:gps-source.hpp>    ////////////////////
  auto pyClassRawGPSSource =
      nb::class_<pacer::RawGPSSource, pacer::RawGPSSource_trampoline>
          (m, "RawGPSSource", "/ Base class for raw GPS source.\n/\n/ Being raw in this context means that it does not provide any meaningful\n/ timestamps to work with.")
      .def(nb::init<>())
      .def("read_samples",
          &pacer::RawGPSSource::ReadSamples, nb::arg("on_sample"))
      .def("seek",
          &pacer::RawGPSSource::Seek,
          nb::arg("target"),
          "/ Seeks to data chunk covering target.")
      .def("next",
          &pacer::RawGPSSource::Next, "/ Proceeds to next piece of data.")
      .def("is_end",
          &pacer::RawGPSSource::IsEnd, "/ Checks whenever we already reachend end of the stream.")
      .def("current_time_span",
          &pacer::RawGPSSource::CurrentTimeSpan, "/ Returns current samples' time span.")
      .def("get_total_duration",
          &pacer::RawGPSSource::GetTotalDuration, "/ Gets total MP4 duration.")
      ;


  auto pyClassGPMFSource =
      nb::class_<pacer::GPMFSource, pacer::RawGPSSource>
          (m, "GPMFSource", "/ Handler for GPMF track inside MP4 container.\n/\n/ Allows for traversing media file and getting GPS data out of it.\n/\n/ TODO: Provide even more low-level access to underlying samples,\n/       might be useful to keep buffer for data in some sort of iterator\n/       with option to iterate over GPSSample-s on top of it.")
      .def(nb::init<size_t>(),
          nb::arg("mp4handle"))
      .def(nb::init<const char *>(),
          nb::arg("filename"))
      .def("seek",
          &pacer::GPMFSource::Seek,
          nb::arg("target"),
          "/ Seeks to data chunk covering target.")
      .def("next",
          &pacer::GPMFSource::Next, "/ Proceeds to next piece of data.")
      .def("is_end",
          &pacer::GPMFSource::IsEnd, "/ Checks whenever we already reachend end of the stream.")
      .def("current_time_span",
          &pacer::GPMFSource::CurrentTimeSpan, "/ Returns current samples' time span.")
      .def("get_total_duration",
          &pacer::GPMFSource::GetTotalDuration, "/ Gets total MP4 duration.")
      ;


  auto pyClassSequentialGPSSource =
      nb::class_<pacer::SequentialGPSSource, pacer::RawGPSSource>
          (m, "SequentialGPSSource", "")
      .def(nb::init<pacer::RawGPSSource *, pacer::RawGPSSource *>(),
          nb::arg("left"), nb::arg("right"))
      .def("get_total_duration",
          &pacer::SequentialGPSSource::GetTotalDuration)
      .def("is_end",
          &pacer::SequentialGPSSource::IsEnd)
      .def("seek",
          &pacer::SequentialGPSSource::Seek, nb::arg("target"))
      .def("next",
          &pacer::SequentialGPSSource::Next)
      .def("current_time_span",
          &pacer::SequentialGPSSource::CurrentTimeSpan, "/ Returns current samples' time span.")
      ;


  auto pyEnumDatVersion =
      nb::enum_<pacer::DatVersion>(m, "DatVersion", nb::is_arithmetic(), "")
          .value("just_data", pacer::DatVersion::JUST_DATA, "")
          .value("with_timestamp", pacer::DatVersion::WITH_TIMESTAMP, "");
  ////////////////////    </generated_from:gps-source.hpp>    ////////////////////


  ////////////////////    <generated_from:laps-display.hpp>    ////////////////////
  auto pyClassLapsDisplay =
      nb::class_<pacer::LapsDisplay>
          (m, "LapsDisplay", "")
      .def("__init__", [](pacer::LapsDisplay * self, int selected_lap = -1, CoordinateSystem cs = CoordinateSystem())
      {
          new (self) pacer::LapsDisplay();  // placement new
          auto r_ctor_ = self;
          r_ctor_->selected_lap = selected_lap;
          r_ctor_->cs = cs;
      },
      nb::arg("selected_lap") = -1, nb::arg("cs") = CoordinateSystem()
      )
      .def_rw("laps", &pacer::LapsDisplay::laps, "")
      .def_rw("selected_lap", &pacer::LapsDisplay::selected_lap, "")
      .def_rw("cs", &pacer::LapsDisplay::cs, "")
      .def("to_im_plot_point",
          &pacer::LapsDisplay::ToImPlotPoint, nb::arg("s"))
      .def_rw("bounds", &pacer::LapsDisplay::bounds, "")
      .def("drag_timing_line",
          &pacer::LapsDisplay::DragTimingLine, nb::arg("s"), nb::arg("name"), nb::arg("drag_id"))
      .def("display_map",
          &pacer::LapsDisplay::DisplayMap)
      .def("display_lap_telemetry",
          &pacer::LapsDisplay::DisplayLapTelemetry)
      .def("display_table",
          &pacer::LapsDisplay::DisplayTable)
      ;


  auto pyClassDeltaLapsComparision =
      nb::class_<pacer::DeltaLapsComparision>
          (m, "DeltaLapsComparision", "")
      .def("__init__", [](pacer::DeltaLapsComparision * self, Lap reference_lap = Lap(), CoordinateSystem cs = CoordinateSystem(), std::unordered_set<int> selected_laps = {})
      {
          new (self) pacer::DeltaLapsComparision();  // placement new
          auto r_ctor_ = self;
          r_ctor_->reference_lap = reference_lap;
          r_ctor_->cs = cs;
          r_ctor_->selected_laps = selected_laps;
      },
      nb::arg("reference_lap") = Lap(), nb::arg("cs") = CoordinateSystem(), nb::arg("selected_laps") = std::unordered_set<int>{}
      )
      .def_rw("reference_lap", &pacer::DeltaLapsComparision::reference_lap, "")
      .def_rw("cs", &pacer::DeltaLapsComparision::cs, "")
      .def("plot_sticks",
          &pacer::DeltaLapsComparision::PlotSticks)
      .def("draw_slider",
          &pacer::DeltaLapsComparision::DrawSlider)
      .def_rw("selected_laps", &pacer::DeltaLapsComparision::selected_laps, "{19, 24, 28, 35, 36};")
      .def("display",
          &pacer::DeltaLapsComparision::Display, nb::arg("laps"))
      ;
  ////////////////////    </generated_from:laps-display.hpp>    ////////////////////

  // </litgen_pydef> // Autogenerated code end
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  pyClassGPSSample.def("__repr__", [](const pacer::GPSSample &s) {
    return "GPSSample(lat=" + std::to_string(s.lat) +
           ", lon=" + std::to_string(s.lon) +
           ", altitude=" + std::to_string(s.altitude) +
           ", full_speed=" + std::to_string(s.full_speed) +
           ", ground_speed=" + std::to_string(s.ground_speed) + ")";
  });

  pyClassPoint.def("__repr__", [](const pacer::Point &p) {
    return "Point(x=" + std::to_string(p.x) + ", y=" + std::to_string(p.y) +
           ")";
  });

  pyClassVec3f.def("__repr__", [](const pacer::Vec3f &v) {
    return "Vec3f(x=" + std::to_string(v.x) + ", y=" + std::to_string(v.y) +
           ", z=" + std::to_string(v.z) + ")";
  });

  pyClassSegment.def("__repr__", [](const pacer::Segment &s) {
    return "Segment(first=" + std::to_string(s.first.x) + ", " +
           std::to_string(s.first.y) +
           ", second=" + std::to_string(s.second.x) + ", " +
           std::to_string(s.second.y) + ")";
  });
}